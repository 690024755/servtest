package com.galaxyeye.websocket.tool.date;/* * Description:com.galaxyeye.websocket.tool.Date * @Date Create on 10:40 * @author <a href="mailto:yangyi@galaxyeye-tech.com">yangyi</a> * @Version JDK 1.8 * @since version 1.0 Copyright 2019-02-27æ—¥SXC All Rights Reserved. */import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import java.math.BigDecimal;import java.sql.Timestamp;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;@Slf4jpublic class DateTool {/** * new a Calendar instance */static GregorianCalendar cldr = new GregorianCalendar();	public static final long DAYMILLI = 24 * 60 * 60 * 1000;	public static final long HOURMILLI = 60 * 60 * 1000;	public static final long MINUTEMILLI = 60 * 1000;	public static final long SECONDMILLI = 1000;	public static final String TIMETO = " 23:59:59";static {		cldr.setTimeZone(java.util.TimeZone.getTimeZone("GMT+9:00"));		}public static final transient int BEFORE = 1;public static final transient int AFTER = 2;public static final transient int EQUAL = 3;public static final String TIME_PATTERN_LONG = "dd/MMM/yyyy:HH:mm:ss +0900";public static final String TIME_PATTERN_LONG2 = "dd/MM/yyyy:HH:mm:ss +0900";public static final String TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";public static final String DB_TIME_PATTERN = "YYYY-MM-DD HH24:MI:SS";public static final String TIME_PATTERN_SHORT = "dd/MM/yy HH:mm:ss";public static final String TIME_PATTERN_SHORT_1 = "yyyy/MM/dd HH:mm";public static final String TIME_PATTERN_SESSION = "yyyyMMddHHmmss";public static final String DATE_FMT_0 = "yyyyMMdd";public static final String DATE_FMT_1 = "yyyy/MM/dd";public static final String DATE_FMT_2 = "yyyy/MM/dd hh:mm:ss";public static final String DATE_FMT_3 = "yyyy-MM-dd";public static final String DATE_FMT_4 = "MM.dd";public static final String DATE_FMT_5 = "yyyy-MM-dd hh:mm:ss";public static final String DATE_FMT_ISO8601 = "yyyy-MM-dd'T'HH:mm:ss'Z'";public static java.util.Date toDate(String sDate, String sFmt) {		if (StringUtils.isBlank(sDate) || StringUtils.isBlank(sFmt)) {		return null;		}		SimpleDateFormat sdfFrom = null;		java.util.Date dt = null;		try {		sdfFrom = new SimpleDateFormat(sFmt);		dt = sdfFrom.parse(sDate);		} catch (Exception ex) {		log.error("An toDate exception occurs: ", ex);		return null;		} finally {		sdfFrom = null;		}		return dt;		}public static String toString(java.util.Date dt) {		return toString(dt, DATE_FMT_0);		}public static String toString(java.util.Date dt, String sFmt) {		if (null == dt || StringUtils.isBlank(sFmt)) {		return null;		}		SimpleDateFormat sdfFrom = null;		String sRet = null;		try {		sdfFrom = new SimpleDateFormat(sFmt);		sRet = sdfFrom.format(dt).toString();		} catch (Exception ex) {		log.error("An toString exception occurs: ", ex);		return null;		} finally {		sdfFrom = null;		}		return sRet;		}public static Date getMonthLastDate(Date date) {		if (null == date) {		return null;		}		Calendar ca = Calendar.getInstance();		ca.setTime(date);		ca.set(Calendar.HOUR_OF_DAY, 23);		ca.set(Calendar.MINUTE, 59);		ca.set(Calendar.SECOND, 59);		ca.set(Calendar.DAY_OF_MONTH, 1);		ca.add(Calendar.MONTH, 1);		ca.add(Calendar.DAY_OF_MONTH, -1);		Date lastDate = ca.getTime();		return lastDate;		}public static String getMonthLastDate(Date date, String pattern) {		Date lastDate = getMonthLastDate(date);		if (null == lastDate) {		return null;		}		if (StringUtils.isBlank(pattern)) {		pattern = TIME_PATTERN;		}		return toString(lastDate, pattern);		}public static Date getMonthFirstDate(Date date) {		if (null == date) {		return null;		}		Calendar ca = Calendar.getInstance();		ca.setTime(date);		ca.set(Calendar.HOUR_OF_DAY, 0);		ca.set(Calendar.MINUTE, 0);		ca.set(Calendar.SECOND, 0);		ca.set(Calendar.DAY_OF_MONTH, 1);		Date firstDate = ca.getTime();		return firstDate;		}public static Date getLastMonthFirstDate(Date date) {		if (null == date) {		return null;		}		Calendar ca = Calendar.getInstance();		ca.setTime(date);		ca.set(Calendar.HOUR_OF_DAY, 0);		ca.set(Calendar.MINUTE, 0);		ca.set(Calendar.SECOND, 0);		ca.set(Calendar.DAY_OF_MONTH, 1);		ca.add(Calendar.MONTH, -1);		Date firstDate = ca.getTime();		return firstDate;		}public static Date getLastMonthLastDate(Date date) {		if (null == date) {		return null;		}		Calendar ca = Calendar.getInstance();		ca.setTime(date);		ca.set(Calendar.HOUR_OF_DAY, 23);		ca.set(Calendar.MINUTE, 59);		ca.set(Calendar.SECOND, 59);		ca.set(Calendar.DAY_OF_MONTH, 1);		ca.add(Calendar.DAY_OF_MONTH,- 1);		Date lastDate = ca.getTime();		return lastDate;		}public static String getMonthFirstDate(Date date, String pattern) {		Date firstDate = getMonthFirstDate(date);		if (null == firstDate) {		return null;		}		if (StringUtils.isBlank(pattern)) {		pattern = TIME_PATTERN;		}		return toString(firstDate, pattern);		}public static int getIntervalDays(java.util.Date firstDate, java.util.Date lastDate) {		if (null == firstDate || null == lastDate) {		return -1;		}		long intervalMilli = lastDate.getTime() - firstDate.getTime();		return (int) (intervalMilli / (24 * 60 * 60 * 1000));		}public static int getDatesInterval(java.util.Date firstDate, java.util.Date lastDate) throws NullPointerException {		if (null == firstDate) {		throw new NullPointerException("firstDate can not be null!");		}		if (null == lastDate) {		throw new NullPointerException("lastDate can not be null!");		}		long intervalMilli = beginOfADay(lastDate).getTime() - beginOfADay(firstDate).getTime();		BigDecimal b = new BigDecimal(24 * 60 * 60 * 1000);		return new BigDecimal(intervalMilli).divide(b, 0, 0).intValue();		}public static int getTimeIntervalHours(Date firstDate, Date lastDate) {		if (null == firstDate || null == lastDate) {		return -1;		}		long intervalMilli = lastDate.getTime() - firstDate.getTime();		return (int) (intervalMilli / (60 * 60 * 1000));		}public static int getTimeIntervalMins(Date firstDate, Date lastDate) {		if (null == firstDate || null == lastDate) {		return -1;		}		long intervalMilli = lastDate.getTime() - firstDate.getTime();		return (int) (intervalMilli / (60 * 1000));		}public static String formatDate(java.util.Date d, String pattern) {		if (null == d || StringUtils.isBlank(pattern)) {		return null;		}		SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance();		formatter.applyPattern(pattern);		return formatter.format(d);		}public static int compareDate(java.util.Date src, java.util.Date desc) {		if ((src == null) && (desc == null)) {		return EQUAL;		} else if (desc == null) {		return BEFORE;		} else if (src == null) {		return AFTER;		} else {		long timeSrc = src.getTime();		long timeDesc = desc.getTime();		if (timeSrc == timeDesc) {		return EQUAL;		} else {		return (timeDesc > timeSrc) ? AFTER		: BEFORE;		}		}		}public static int compareTwoDate(Date first, Date second) {		if ((first == null) && (second == null)) {		return EQUAL;		} else if (first == null) {		return BEFORE;		} else if (second == null) {		return AFTER;		} else if (first.before(second)) {		return BEFORE;		} else if (first.after(second)) {		return AFTER;		} else {		return EQUAL;		}		}public static boolean isDateBetween(Date date, Date begin, Date end) {		int c1 = compareTwoDate(begin, date);		int c2 = compareTwoDate(date, end);		return (((c1 == BEFORE) && (c2 == BEFORE)) || (c1 == EQUAL) || (c2 == EQUAL));		}public static boolean isDateBetween(java.util.Date myDate, int begin, int end) {		return isDateBetween(myDate, getCurrentDateTime(), begin, end);		}public static boolean isDateBetween(java.util.Date utilDate, java.util.Date dateBaseLine,		int begin, int end) {		String pattern = TIME_PATTERN;		String my = toString(utilDate, pattern);		Date myDate = parseString2Date(my, pattern);		String baseLine = toString(dateBaseLine, pattern);		//		Date baseLineDate = parseString2Date(baseLine, pattern);		String from = addDays(baseLine, begin);		Date fromDate = parseString2Date(from, pattern);		String to = addDays(baseLine, end);		Date toDate = parseString2Date(to, pattern);		return isDateBetween(myDate, fromDate, toDate);		}public static Timestamp parseString2Timestamp(String str, String sFmt) {		if ((str == null) || str.equals("")) {		return null;		}		try {		long time = Long.parseLong(str);		return new Timestamp(time);		} catch (Exception ex) {		try {		DateFormat df = new SimpleDateFormat(sFmt);		java.util.Date dt = df.parse(str);		return new Timestamp(dt.getTime());		} catch (Exception pe) {		try {		return Timestamp.valueOf(str);		} catch (Exception e) {		return null;		}		}		}		}@SuppressWarnings("deprecation")public static Date parseString2Date(String str, String sFmt) {		if ((str == null) || str.equals("")) {		return null;		}		try {		long time = Long.parseLong(str);		return new Date(time);		} catch (Exception ex) {		try {		DateFormat df = new SimpleDateFormat(sFmt);		java.util.Date dt = df.parse(str);		return new Date(dt.getTime());		} catch (Exception pe) {		log.warn("parseString2Date warning:", pe);		try {		return new Date(str);		} catch (Exception e) {		return null;		}		}		}		}	public static java.util.Date addMilliseconds(java.util.Date date, Long milliseconds) {		if (null == date) {			return null;		}		date.setTime(date.getTime()+milliseconds);		return date;	}	public static java.util.Date reduceMilliseconds(java.util.Date date, Long milliseconds) {		if (null == date) {			return null;		}		date.setTime(date.getTime()-milliseconds);		return date;	}public static java.util.Date addDate(java.util.Date date, int day) {		if (null == date) {		return null;		}		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH) + day);		return calendar.getTime();		}public static String addDays(java.util.Date date, int day, String pattern) {		return addDays(toString(date, pattern), day, pattern);		}public static String addDays(java.util.Date date, int day) {		return addDays(toString(date, TIME_PATTERN), day);		}public static String addDays(String date, int day) {		return addDays(date, day, TIME_PATTERN);		}public static String addDays(String date, int day, String pattern) {		if (date == null) {		return "";		}		if (date.equals("")) {		return "";		}		if (day == 0) {		return date;		}		try {		SimpleDateFormat dateFormat = new SimpleDateFormat(pattern);		Calendar calendar = dateFormat.getCalendar();		calendar.setTime(dateFormat.parse(date));		calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH) + day);		return dateFormat.format(calendar.getTime());		} catch (Exception ex) {		log.error("An addDays exception occurs: ", ex);		return "";		}		}public static String formatTimestamp(Timestamp t, String sFmt) {		if (t == null || StringUtils.isBlank(sFmt)) {		return "";		}		t.setNanos(0);		DateFormat ft = new SimpleDateFormat(sFmt);		String str = "";		try {		str = ft.format(t);		} catch (NullPointerException ex) {		log.error("An formatTimestamp exception occur:", ex);		}		return str;		}public static Timestamp parseString(String str, String sFmt) {		if ((str == null) || str.equals("")) {		return null;		}		try {		long time = Long.parseLong(str);		return new Timestamp(time);		} catch (Exception ex) {		try {		DateFormat df = new SimpleDateFormat(sFmt);		java.util.Date dt = df.parse(str);		return new Timestamp(dt.getTime());		} catch (Exception pe) {		try {		return Timestamp.valueOf(str);		} catch (Exception e) {		return null;		}		}		}		}public static Date getCurrentDate() {		return new Date(System.currentTimeMillis());		}public static Calendar getCurrentCalendar() {		return Calendar.getInstance();		}public static Timestamp getCurrentDateTime() {		return new Timestamp(System.currentTimeMillis());		}public static final int getYear(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.YEAR);		}public static final int getYear(long millis) {		Calendar calendar = Calendar.getInstance();		calendar.setTimeInMillis(millis);		return calendar.get(Calendar.YEAR);		}public static final int getMonth(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.MONTH) + 1;		}public static final int getMonth(long millis) {		Calendar calendar = Calendar.getInstance();		calendar.setTimeInMillis(millis);		return calendar.get(Calendar.MONTH) + 1;		}public static final int getDate(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.DATE);		}public static final int getDays(Date date) {		Calendar ca = Calendar.getInstance();		ca.setTime(date);		ca.set(Calendar.HOUR_OF_DAY, 23);		ca.set(Calendar.MINUTE, 59);		ca.set(Calendar.SECOND, 59);		ca.set(Calendar.DAY_OF_MONTH, 1);		ca.add(Calendar.MONTH, 1);		ca.add(Calendar.DAY_OF_MONTH, -1);		return ca.get(Calendar.DAY_OF_MONTH);		}	public static final int getDay(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.DATE);	}	public static final String getTime(Date date) {		return toString(date,"HH:mm:ss");	}public static final int getDate(long millis) {		Calendar calendar = Calendar.getInstance();		calendar.setTimeInMillis(millis);		return calendar.get(Calendar.DATE);		}public static final int getWeekOfDate(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.DAY_OF_WEEK);		}public static final int getHour(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.HOUR_OF_DAY);		}public static final int getMinute(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.MINUTE);		}public static final int getSecond(Date date) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		return calendar.get(Calendar.SECOND);		}public static final int getHour(long millis) {		Calendar calendar = Calendar.getInstance();		calendar.setTimeInMillis(millis);		return calendar.get(Calendar.HOUR_OF_DAY);		}public static final Date zerolizedTime(Date fullDate) {		Calendar cal = Calendar.getInstance();		cal.setTime(fullDate);		cal.set(Calendar.HOUR_OF_DAY, 0);		cal.set(Calendar.MINUTE, 0);		cal.set(Calendar.SECOND, 0);		cal.set(Calendar.MILLISECOND, 0);		return cal.getTime();		}public static Date beginOfADay(Date date) {		return setCalendarTime(date, 0, 0, 0).getTime();		}public static Date endOfADay(Date date) {		return setCalendarTime(date, 23, 59, 59).getTime();		}public static Date specificTimeOfDay(Date date, Integer hour, Integer min, Integer sec) {		return setCalendarTime(date, hour, min, sec).getTime();		}private static Calendar setCalendarTime(Date date, int hour, int min, int sec) {		Calendar cal = Calendar.getInstance();		if (null != date) {		cal.setTime(date);		}		cal.set(Calendar.HOUR_OF_DAY, hour);		cal.set(Calendar.MINUTE, min);		cal.set(Calendar.SECOND, sec);		cal.set(Calendar.MILLISECOND, 0);		return cal;		}	public static Long getCurrentTime() {		return getCurrentDate().getTime();	}	public static Long getCurrentDayEndTime() {		return specificTimeOfDay(new Date(),23,59,59).getTime();	}	public static long diff(Date begin, Date end, int field) {		long diff = end.getTime() - begin.getTime();		if (Calendar.MILLISECOND == field) {			return diff;		}		diff /= 1000;		if (Calendar.SECOND == field) {			return diff;		}		diff /= 60;		if (Calendar.MINUTE == field) {			return diff;		}		diff /= 60;		if (Calendar.HOUR == field || Calendar.HOUR_OF_DAY == field) {			return diff;		}		diff /= 24;		if (Calendar.DAY_OF_MONTH == field || Calendar.DAY_OF_WEEK == field				|| Calendar.DAY_OF_WEEK_IN_MONTH == field || Calendar.DAY_OF_YEAR == field) {			return diff;		}		if (Calendar.MONTH == field) {			return diff / 30;		}		if (Calendar.YEAR == field) {			return diff / 365;		}		return diff;	}	public static Date parseDateStr(String dateStr, String format) {		SimpleDateFormat formatDate = new SimpleDateFormat(format);		try {			return formatDate.parse(dateStr);		} catch (ParseException e) {			return null;		}	}	public static String parseLongTime(Long longTime, String format) {		SimpleDateFormat formatDate = new SimpleDateFormat(format);		Date date= new Date(longTime);		return formatDate.format(date);	}	public static String timeAccumulation(String time) throws Exception {		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");		Date date =df.parse(time);		date.setTime(date.getTime() + 1000);		return df.format(date);	}}